<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> mysql-cdc Â· Finch's Blog</title><meta name="description" content="mysql-cdc - Finch Xia"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://Adooobe.github.io/atom.xml" title="Finch's Blog"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Finch's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Adooobe" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">mysql-cdc</h1><div class="post-info">Dec 21, 2023</div><div class="post-content"><h2 id="CDC-Process"><a href="#CDC-Process" class="headerlink" title="CDC Process"></a>CDC Process</h2><p>A common binlog stream reader contains the parts as follows. However, in many open source library or project, some important steps are boxed as internal processes. Frequently, user should only concern about the connection to the server and how to handle the BinlogEvents. I will use <a target="_blank" rel="noopener" href="https://github.com/rusuly/mysql_cdc">rust-mysql-cdc</a> to introduce the whole process of mysql cdc.</p>
<h3 id="Connect-to-MySQL-Server-amp-Authentication"><a href="#Connect-to-MySQL-Server-amp-Authentication" class="headerlink" title="Connect to MySQL Server &amp; Authentication"></a>Connect to MySQL Server &amp; Authentication</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">connect</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(PacketChannel, DatabaseProvider), Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = PacketChannel::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">self</span>.options)?;</span><br><span class="line">        <span class="keyword">let</span> (packet, seq_num) = channel.<span class="title function_ invoke__">read_packet</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">check_error_packet</span>(&amp;packet, <span class="string">&quot;Initial handshake error.&quot;</span>)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handshake</span> = HandshakePacket::<span class="title function_ invoke__">parse</span>(&amp;packet)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">auth_plugin</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_auth_plugin</span>(&amp;handshake.auth_plugin_name)?;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">authenticate</span>(&amp;<span class="keyword">mut</span> channel, &amp;handshake, auth_plugin, seq_num + <span class="number">1</span>)?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>((channel, DatabaseProvider::<span class="title function_ invoke__">from</span>(&amp;handshake.server_version)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>User provides the connection info and get one PacketChannel(TCPStream).</li>
<li>Get authentication method and authenticate</li>
</ol>
<h3 id="Register-as-a-slave"><a href="#Register-as-a-slave" class="headerlink" title="Register as a slave"></a>Register as a slave</h3><p><a target="_blank" rel="noopener" href="https://mariadb.com/kb/en/com_register_slave/">RegisterSlave</a></p>
<p>In Rust, we need to construct a message and send to the PacketChannel as above which includes</p>
<ul>
<li>COM_REGISTER_SLAVE command</li>
<li>server_id</li>
<li><strong>Empty</strong> host user password port rank masterid</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">RegisterSlaveCommand</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(server_id: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; server_id &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">serialize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, io::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cursor</span> = Cursor::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> vec);</span><br><span class="line"></span><br><span class="line">        cursor.<span class="title function_ invoke__">write_u8</span>(CommandType::RegisterSlave <span class="keyword">as</span> <span class="type">u8</span>)?;</span><br><span class="line">        cursor.write_u32::&lt;LittleEndian&gt;(<span class="keyword">self</span>.server_id)?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Empty host, user, password, port, rank, masterid</span></span><br><span class="line">        cursor.<span class="title function_ invoke__">write_u8</span>(<span class="number">0</span>)?;</span><br><span class="line">        cursor.<span class="title function_ invoke__">write_u8</span>(<span class="number">0</span>)?;</span><br><span class="line">        cursor.<span class="title function_ invoke__">write_u8</span>(<span class="number">0</span>)?;</span><br><span class="line">        cursor.write_u16::&lt;LittleEndian&gt;(<span class="number">0</span>)?;</span><br><span class="line">        cursor.write_u32::&lt;LittleEndian&gt;(<span class="number">0</span>)?;</span><br><span class="line">        cursor.write_u32::&lt;LittleEndian&gt;(<span class="number">0</span>)?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(vec)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Binlog-Dump"><a href="#Binlog-Dump" class="headerlink" title="Binlog Dump"></a>Binlog Dump</h3><p>Same as RegisterSlave, DumpBinogCommand needs:</p>
<ul>
<li>server_id</li>
<li>binlog_filename</li>
<li>binlog_position</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DumpBinlogCommand</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> server_id: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> binlog_filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> binlog_position: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> flags: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">DumpBinlogCommand</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(server_id: <span class="type">u32</span>, binlog_filename: <span class="type">String</span>, binlog_position: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            server_id,</span><br><span class="line">            binlog_filename,</span><br><span class="line">            binlog_position,</span><br><span class="line">            flags: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">serialize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, io::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cursor</span> = Cursor::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> vec);</span><br><span class="line"></span><br><span class="line">        cursor.<span class="title function_ invoke__">write_u8</span>(CommandType::BinlogDump <span class="keyword">as</span> <span class="type">u8</span>)?;</span><br><span class="line">        cursor.write_u32::&lt;LittleEndian&gt;(<span class="keyword">self</span>.binlog_position)?;</span><br><span class="line">        cursor.write_u16::&lt;LittleEndian&gt;(<span class="keyword">self</span>.flags)?;</span><br><span class="line">        cursor.write_u32::&lt;LittleEndian&gt;(<span class="keyword">self</span>.server_id)?;</span><br><span class="line">        cursor.<span class="title function_ invoke__">write</span>(<span class="keyword">self</span>.binlog_filename.<span class="title function_ invoke__">as_bytes</span>())?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(vec)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Handle-Binlog-Events"><a href="#Handle-Binlog-Events" class="headerlink" title="Handle Binlog Events"></a>Handle Binlog Events</h3><p>As mentioned above, usually, we let users handle these events but firstly, we need to parse them.</p>
<h3 id="HeartBeats"><a href="#HeartBeats" class="headerlink" title="HeartBeats"></a>HeartBeats</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_master_heartbeat</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, channel: &amp;<span class="keyword">mut</span> PacketChannel) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">milliseconds</span> = <span class="keyword">self</span>.options.heartbeat_interval.<span class="title function_ invoke__">as_millis</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nanoseconds</span> = milliseconds * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = <span class="built_in">format!</span>(<span class="string">&quot;set @master_heartbeat_period=&#123;&#125;&quot;</span>, nanoseconds);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">command</span> = QueryCommand::<span class="title function_ invoke__">new</span>(query.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    channel.<span class="title function_ invoke__">write_packet</span>(&amp;command.<span class="title function_ invoke__">serialize</span>()?, <span class="number">0</span>)?;</span><br><span class="line">    <span class="keyword">let</span> (packet, _) = channel.<span class="title function_ invoke__">read_packet</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">check_error_packet</span>(&amp;packet, <span class="string">&quot;Setting master heartbeat error.&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Get-Better-Performance"><a href="#Get-Better-Performance" class="headerlink" title="Get Better Performance"></a>Get Better Performance</h3><p>As we know, it is impossible for a CDC program to pull and parse binlog events infinitely as a slave. Also, as a developer, you may be not able to adjust the MySQL server parameters to improve the CDC performance. There are some suggestions for you if you are trouble with any relationed issues.</p>
<h4 id="Batch-Processing"><a href="#Batch-Processing" class="headerlink" title="Batch-Processing"></a>Batch-Processing</h4><p>For the only slave, you can use batch processing anywhere except pulling binlog events like <strong>parse events</strong>, <strong>handle events</strong> or <strong>sink the events.</strong> There is an example that I used in parsing binlog events.</p>
<ol>
<li>Parser for parsing a single binlog events</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read_data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">Option</span>&lt;EventData&lt;<span class="symbol">&#x27;_</span>&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">use</span> EventType::*;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">event_type</span> = <span class="keyword">match</span> <span class="keyword">self</span>.header.event_type.<span class="title function_ invoke__">get</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(event_type) =&gt; event_type,</span><br><span class="line">            _ =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">event_data</span> = <span class="keyword">match</span> event_type &#123;</span><br><span class="line">            ENUM_END_EVENT | UNKNOWN_EVENT =&gt; EventData::UnknownEvent,</span><br><span class="line">            START_EVENT_V3 =&gt; EventData::<span class="title function_ invoke__">StartEventV3</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            QUERY_EVENT =&gt; EventData::<span class="title function_ invoke__">QueryEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            STOP_EVENT =&gt; EventData::StopEvent,</span><br><span class="line">            ROTATE_EVENT =&gt; EventData::<span class="title function_ invoke__">RotateEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            INTVAR_EVENT =&gt; EventData::<span class="title function_ invoke__">IntvarEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            LOAD_EVENT =&gt; EventData::<span class="title function_ invoke__">LoadEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            SLAVE_EVENT =&gt; EventData::SlaveEvent,</span><br><span class="line">            CREATE_FILE_EVENT =&gt; EventData::<span class="title function_ invoke__">CreateFileEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            APPEND_BLOCK_EVENT =&gt; EventData::<span class="title function_ invoke__">AppendBlockEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            EXEC_LOAD_EVENT =&gt; EventData::<span class="title function_ invoke__">ExecLoadEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            DELETE_FILE_EVENT =&gt; EventData::<span class="title function_ invoke__">DeleteFileEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            NEW_LOAD_EVENT =&gt; EventData::<span class="title function_ invoke__">NewLoadEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            RAND_EVENT =&gt; EventData::<span class="title function_ invoke__">RandEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            USER_VAR_EVENT =&gt; EventData::<span class="title function_ invoke__">UserVarEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            FORMAT_DESCRIPTION_EVENT =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">fde</span> = <span class="keyword">self</span></span><br><span class="line">                    .read_event::&lt;FormatDescriptionEvent&gt;()?</span><br><span class="line">                    .<span class="title function_ invoke__">with_footer</span>(<span class="keyword">self</span>.footer);</span><br><span class="line">                EventData::<span class="title function_ invoke__">FormatDescriptionEvent</span>(fde)</span><br><span class="line">            &#125;</span><br><span class="line">            XID_EVENT =&gt; EventData::<span class="title function_ invoke__">XidEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            BEGIN_LOAD_QUERY_EVENT =&gt; EventData::<span class="title function_ invoke__">BeginLoadQueryEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            EXECUTE_LOAD_QUERY_EVENT =&gt; EventData::<span class="title function_ invoke__">ExecuteLoadQueryEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            TABLE_MAP_EVENT =&gt; EventData::<span class="title function_ invoke__">TableMapEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            PRE_GA_WRITE_ROWS_EVENT =&gt; EventData::<span class="title function_ invoke__">PreGaWriteRowsEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            PRE_GA_UPDATE_ROWS_EVENT =&gt; EventData::<span class="title function_ invoke__">PreGaUpdateRowsEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            PRE_GA_DELETE_ROWS_EVENT =&gt; EventData::<span class="title function_ invoke__">PreGaDeleteRowsEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            WRITE_ROWS_EVENT_V1 =&gt; &#123;</span><br><span class="line">                EventData::<span class="title function_ invoke__">RowsEvent</span>(RowsEventData::<span class="title function_ invoke__">WriteRowsEventV1</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?))</span><br><span class="line">            &#125;</span><br><span class="line">            UPDATE_ROWS_EVENT_V1 =&gt; &#123;</span><br><span class="line">                EventData::<span class="title function_ invoke__">RowsEvent</span>(RowsEventData::<span class="title function_ invoke__">UpdateRowsEventV1</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?))</span><br><span class="line">            &#125;</span><br><span class="line">            DELETE_ROWS_EVENT_V1 =&gt; &#123;</span><br><span class="line">                EventData::<span class="title function_ invoke__">RowsEvent</span>(RowsEventData::<span class="title function_ invoke__">DeleteRowsEventV1</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?))</span><br><span class="line">            &#125;</span><br><span class="line">            INCIDENT_EVENT =&gt; EventData::<span class="title function_ invoke__">IncidentEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            HEARTBEAT_EVENT =&gt; EventData::HeartbeatEvent,</span><br><span class="line">            IGNORABLE_EVENT =&gt; EventData::<span class="title function_ invoke__">IgnorableEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            ROWS_QUERY_EVENT =&gt; EventData::<span class="title function_ invoke__">RowsQueryEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            WRITE_ROWS_EVENT =&gt; &#123;</span><br><span class="line">                EventData::<span class="title function_ invoke__">RowsEvent</span>(RowsEventData::<span class="title function_ invoke__">WriteRowsEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?))</span><br><span class="line">            &#125;</span><br><span class="line">            UPDATE_ROWS_EVENT =&gt; &#123;</span><br><span class="line">                EventData::<span class="title function_ invoke__">RowsEvent</span>(RowsEventData::<span class="title function_ invoke__">UpdateRowsEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?))</span><br><span class="line">            &#125;</span><br><span class="line">            DELETE_ROWS_EVENT =&gt; &#123;</span><br><span class="line">                EventData::<span class="title function_ invoke__">RowsEvent</span>(RowsEventData::<span class="title function_ invoke__">DeleteRowsEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?))</span><br><span class="line">            &#125;</span><br><span class="line">            GTID_EVENT =&gt; EventData::<span class="title function_ invoke__">GtidEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            ANONYMOUS_GTID_EVENT =&gt; EventData::<span class="title function_ invoke__">AnonymousGtidEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">            PREVIOUS_GTIDS_EVENT =&gt; EventData::<span class="title function_ invoke__">PreviousGtidsEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            TRANSACTION_CONTEXT_EVENT =&gt; &#123;</span><br><span class="line">                EventData::<span class="title function_ invoke__">TransactionContextEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data))</span><br><span class="line">            &#125;</span><br><span class="line">            VIEW_CHANGE_EVENT =&gt; EventData::<span class="title function_ invoke__">ViewChangeEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            XA_PREPARE_LOG_EVENT =&gt; EventData::<span class="title function_ invoke__">XaPrepareLogEvent</span>(Cow::<span class="title function_ invoke__">Borrowed</span>(&amp;*<span class="keyword">self</span>.data)),</span><br><span class="line">            PARTIAL_UPDATE_ROWS_EVENT =&gt; &#123;</span><br><span class="line">                EventData::<span class="title function_ invoke__">RowsEvent</span>(RowsEventData::<span class="title function_ invoke__">PartialUpdateRowsEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?))</span><br><span class="line">            &#125;</span><br><span class="line">            TRANSACTION_PAYLOAD_EVENT =&gt; EventData::<span class="title function_ invoke__">TransactionPayloadEvent</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>()?),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(event_data))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Use the Rayon framework to enable concurrency</li>
</ol>
<p>Many operations in Rayon, such as map(), filter_map(), and others, do not inherently guarantee that the output order will be the same as the input order. However, when used in combination with collect(), they generally ensure the results are in order. So, if the order of data is needed, please write a test case to test your code.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">result</span> <span class="keyword">in</span> client.<span class="title function_ invoke__">replicate</span>()? &#123;</span><br><span class="line">        <span class="keyword">let</span> (header, event) = result?;</span><br><span class="line">        event_queue.<span class="title function_ invoke__">enqueue</span>((header, event));</span><br><span class="line">        event_count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> event_count.<span class="title function_ invoke__">borrow</span>() % <span class="number">100000</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">event_array</span> = event_queue.<span class="title function_ invoke__">drain_all</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">new_arr</span>: <span class="type">Vec</span>&lt;(EventHeader, <span class="type">Result</span>&lt;BinlogEvent, Error&gt;)&gt; = event_array.<span class="title function_ invoke__">into_par_iter</span>().<span class="title function_ invoke__">map</span>(|(header, payload)| &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c_table_map</span> = table_map.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">parsed_event</span> = <span class="title function_ invoke__">parse_event</span>(&amp;header, &amp;payload, &amp;<span class="keyword">mut</span> c_table_map);</span><br><span class="line">                (header, parsed_event)</span><br><span class="line">            &#125;).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">dur</span> = start_time.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Process Time Duration: &#123;:?&#125;&quot;</span>, dur);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Current Binlog Events: &#123;:?&#125;&quot;</span>, event_count);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Result Length: &#123;:?&#125;&quot;</span>, new_arr.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Choose the needed events</li>
</ol>
<p>Normally, in CDC program, several binlog event types are as follows:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(non_camel_case_types)]</span></span><br><span class="line"><span class="meta">#[repr(u8)]</span></span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">EventType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A `QUERY_EVENT` is created for each query that modifies the database,</span></span><br><span class="line">    <span class="comment">/// unless the query is logged row-based.</span></span><br><span class="line">    QUERY_EVENT = <span class="number">0x02</span>,</span><br><span class="line">    <span class="comment">/// to tell the reader what binlog to request next.</span></span><br><span class="line">    ROTATE_EVENT = <span class="number">0x04</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// if any transaction commit info needed</span></span><br><span class="line">    XID_EVENT = <span class="number">0x10</span>,</span><br><span class="line">  </span><br><span class="line">    TABLE_MAP_EVENT = <span class="number">0x13</span>,</span><br><span class="line">   </span><br><span class="line">    WRITE_ROWS_EVENT_V1 = <span class="number">0x17</span>,</span><br><span class="line">    UPDATE_ROWS_EVENT_V1 = <span class="number">0x18</span>,</span><br><span class="line">    DELETE_ROWS_EVENT_V1 = <span class="number">0x19</span>,</span><br><span class="line">  </span><br><span class="line">    WRITE_ROWS_EVENT = <span class="number">0x1e</span>,</span><br><span class="line">    UPDATE_ROWS_EVENT = <span class="number">0x1f</span>,</span><br><span class="line">    DELETE_ROWS_EVENT = <span class="number">0x20</span>,</span><br><span class="line">    GTID_EVENT = <span class="number">0x21</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Add iterator for your binlog stream reader</li>
</ol>
<p>In my code, <code>client.replicate()</code> will return <code>Result&lt;BinlogEvents, Error&gt;</code>. So we need to implement Iterator trait for BinlogEvents.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">BinlogEvents</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">Result</span>&lt;(EventHeader, <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;), Error&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Reads binlog event packets from network stream.</span></span><br><span class="line">    <span class="comment">/// &lt;a href=&quot;https://mariadb.com/kb/en/3-binlog-network-stream/&quot;&gt;See more&lt;/a&gt;</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> (packet, _) = <span class="keyword">match</span> <span class="keyword">self</span>.channel.<span class="title function_ invoke__">read_packet</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(x) =&gt; x,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">IoError</span>(e))),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">match</span> packet[<span class="number">0</span>] &#123;</span><br><span class="line">            ResponseType::OK =&gt; <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_event</span>(&amp;packet)),</span><br><span class="line">            ResponseType::ERROR =&gt; <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">read_error</span>(&amp;packet)),</span><br><span class="line">            ResponseType::END_OF_FILE =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">_</span> = EndOfFilePacket::<span class="title function_ invoke__">parse</span>(&amp;packet[<span class="number">1</span>..]);</span><br><span class="line">                <span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">String</span>(</span><br><span class="line">                <span class="string">&quot;Unknown network stream status&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            ))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In another case, the binlog stream reader implements the Stream trait like <code>while let Ok(Some(c)) = cdc_stream.try_next().await</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">futures_core</span>::stream::Stream <span class="keyword">for</span> <span class="title class_">BinlogStream</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">Result</span>&lt;ChgcapEvent&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll_next</span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> Poll&lt;<span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">this</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_mut</span>();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Support rate limiting.</span></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">binlog_stream</span> = Pin::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> this.binlog_stream);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">match</span> binlog_stream.<span class="title function_ invoke__">poll_next</span>(cx) &#123;</span><br><span class="line">                Poll::<span class="title function_ invoke__">Ready</span>(t) =&gt; <span class="keyword">match</span> t &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(event_result) =&gt; <span class="keyword">match</span> event_result &#123;</span><br><span class="line">                        <span class="title function_ invoke__">Ok</span>(event) =&gt; <span class="keyword">match</span> this.<span class="title function_ invoke__">handle_event</span>(event) &#123; <span class="comment">// here</span></span><br><span class="line">                            <span class="title function_ invoke__">Ok</span>(change) =&gt; <span class="keyword">match</span> change &#123;</span><br><span class="line">                                <span class="title function_ invoke__">Some</span>(c) =&gt; Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Ok</span>(c))),</span><br><span class="line">                                <span class="literal">None</span> =&gt; <span class="keyword">continue</span>, <span class="comment">// Skip this event.</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="title function_ invoke__">Err</span>(e) =&gt; Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Err</span>(e))),</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="title function_ invoke__">Err</span>(err) =&gt; Poll::<span class="title function_ invoke__">Ready</span>(<span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">Err</span>(anyhow!(err)))),</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="literal">None</span> =&gt; Poll::<span class="title function_ invoke__">Ready</span>(<span class="literal">None</span>), <span class="comment">// Completed.</span></span><br><span class="line">                &#125;,</span><br><span class="line">                Poll::Pending =&gt; Poll::Pending,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>Accumulate unprocessed binlog events into a batch like Step 2</li>
</ol>
<h4 id="Multiple-Slave"><a href="#Multiple-Slave" class="headerlink" title="Multiple Slave"></a>Multiple Slave</h4><p>In <strong>Batch-Processing</strong> section, we can boost the performance of CDC from tens of thousands of events to over a hundred thousand events per second. But however, if you need higher performance, single-instance batching may not meet your needs.</p>
<p>Luckily, there is an another road to make it. Before introducing this way, let us take eyes on <strong>table_id</strong>.</p>
<ul>
<li>table_id is 6 bytes, need pad little-endian number.</li>
<li>table_id is a temporary value. it would be changed when:<ul>
<li>drop and replace table</li>
<li>rename table</li>
<li>alter table</li>
<li>MySQL Engine upgrade</li>
</ul>
</li>
<li>Before every data change events(WriteRowsEvent, UpdateRowsEvent, DeleteRowsEvent), there would be a TableMapEvent including table name, table id and table schema.</li>
</ul>
<p>Next, you should know how to get table metadata from TableMapEvent.</p>
<p><img src="/2023/12/21/mysql-cdc/table_map_event.png" alt="TableMapEvent"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TableMapEvent</span>(<span class="title class_ inherited__">BinLogEvent</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This event describes the structure of a table.</span></span><br><span class="line"><span class="string">    It&#x27;s sent before a change happens on a table.</span></span><br><span class="line"><span class="string">    An end user of the lib should have no usage of this</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, from_packet, event_size, table_map, ctl_connection, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(TableMapEvent, self).__init__(from_packet, event_size,</span><br><span class="line">                                            table_map, ctl_connection, **kwargs)</span><br><span class="line">        self.__only_tables = kwargs[<span class="string">&quot;only_tables&quot;</span>]</span><br><span class="line">        self.__ignored_tables = kwargs[<span class="string">&quot;ignored_tables&quot;</span>]</span><br><span class="line">        self.__only_schemas = kwargs[<span class="string">&quot;only_schemas&quot;</span>]</span><br><span class="line">        self.__ignored_schemas = kwargs[<span class="string">&quot;ignored_schemas&quot;</span>]</span><br><span class="line">        self.__freeze_schema = kwargs[<span class="string">&quot;freeze_schema&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Post-Header</span></span><br><span class="line">        self.table_id = self._read_table_id()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.table_id <span class="keyword">in</span> table_map <span class="keyword">and</span> self.__freeze_schema:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.flags = struct.unpack(<span class="string">&#x27;&lt;H&#x27;</span>, self.packet.read(<span class="number">2</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Payload</span></span><br><span class="line">        self.schema_length = struct.unpack(<span class="string">&quot;!B&quot;</span>, self.packet.read(<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line">        self.schema = self.packet.read(self.schema_length).decode()</span><br><span class="line">        self.packet.advance(<span class="number">1</span>)</span><br><span class="line">        self.table_length = struct.unpack(<span class="string">&quot;!B&quot;</span>, self.packet.read(<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line">        self.table = self.packet.read(self.table_length).decode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__only_tables <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.table <span class="keyword">not</span> <span class="keyword">in</span> self.__only_tables:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.__ignored_tables <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.table <span class="keyword">in</span> self.__ignored_tables:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__only_schemas <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.schema <span class="keyword">not</span> <span class="keyword">in</span> self.__only_schemas:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.__ignored_schemas <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.schema <span class="keyword">in</span> self.__ignored_schemas:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.packet.advance(<span class="number">1</span>)</span><br><span class="line">        self.column_count = self.packet.read_length_coded_binary()</span><br><span class="line"></span><br><span class="line">        self.columns = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.table_id <span class="keyword">in</span> table_map:</span><br><span class="line">            self.column_schemas = table_map[self.table_id].column_schemas</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.column_schemas = self._ctl_connection._get_table_information(self.schema, self.table)</span><br><span class="line"></span><br><span class="line">        ordinal_pos_loc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.column_schemas) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Read columns meta data</span></span><br><span class="line">            column_types = <span class="built_in">bytearray</span>(self.packet.read(self.column_count))</span><br><span class="line">            self.packet.read_length_coded_binary()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(column_types)):</span><br><span class="line">                column_type = column_types[i]</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    column_schema = self.column_schemas[ordinal_pos_loc]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># only acknowledge the column definition if the iteration matches with ordinal position of</span></span><br><span class="line">                    <span class="comment"># the column. this helps in maintaining support for restricted columnar access</span></span><br><span class="line">                    <span class="keyword">if</span> i != (column_schema[<span class="string">&#x27;ORDINAL_POSITION&#x27;</span>] - <span class="number">1</span>):</span><br><span class="line">                        <span class="comment"># raise IndexError to follow the workflow of dropping columns which are not matching the</span></span><br><span class="line">                        <span class="comment"># underlying table schema</span></span><br><span class="line">                        <span class="keyword">raise</span> IndexError</span><br><span class="line"></span><br><span class="line">                    ordinal_pos_loc += <span class="number">1</span></span><br><span class="line">                <span class="keyword">except</span> IndexError:</span><br><span class="line">                    <span class="comment"># this a dirty hack to prevent row events containing columns which have been dropped prior</span></span><br><span class="line">                    <span class="comment"># to pymysqlreplication start, but replayed from binlog from blowing up the service.</span></span><br><span class="line">                    <span class="comment"># <span class="doctag">TODO:</span> this does not address the issue if the column other than the last one is dropped</span></span><br><span class="line">                    column_schema = &#123;</span><br><span class="line">                        <span class="string">&#x27;COLUMN_NAME&#x27;</span>: <span class="string">&#x27;__dropped_col_&#123;i&#125;__&#x27;</span>.<span class="built_in">format</span>(i=i),</span><br><span class="line">                        <span class="string">&#x27;COLLATION_NAME&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">                        <span class="string">&#x27;CHARACTER_SET_NAME&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">                        <span class="string">&#x27;COLUMN_COMMENT&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">                        <span class="string">&#x27;COLUMN_TYPE&#x27;</span>: <span class="string">&#x27;BLOB&#x27;</span>,  <span class="comment"># we don&#x27;t know what it is, so let&#x27;s not do anything with it.</span></span><br><span class="line">                        <span class="string">&#x27;COLUMN_KEY&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                col = Column(column_type, column_schema, from_packet)</span><br><span class="line">                self.columns.append(col)</span><br><span class="line"></span><br><span class="line">        self.table_obj = Table(self.column_schemas, self.table_id, self.schema,</span><br><span class="line">                               self.table, self.columns)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ith column is nullable if (i - 1)th bit is set to True, not nullable otherwise</span></span><br><span class="line">        <span class="comment">## Refer to definition of and call to row.event._is_null() to interpret bitmap corresponding to columns</span></span><br><span class="line">        self.null_bitmask = self.packet.read((self.column_count + <span class="number">7</span>) / <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>Congratulations! You have known how to divide your binlog stream reader to different database(schema) / table.</p>
<p><img src="/2023/12/21/mysql-cdc/row_events.png" alt="RowEvents"></p>
<p>For TableMapEvent, we can store the table_id for the RowEvents. When any RowEvents parse the table_id and it is not in the table map cache, the event should be ignored.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RowsEvent</span>(<span class="title class_ inherited__">BinLogEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, from_packet, event_size, table_map, ctl_connection, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(RowsEvent, self).__init__(from_packet, event_size, table_map,</span><br><span class="line">                                        ctl_connection, **kwargs)</span><br><span class="line">        self.__rows = <span class="literal">None</span></span><br><span class="line">        self.__only_tables = kwargs[<span class="string">&quot;only_tables&quot;</span>]</span><br><span class="line">        self.__ignored_tables = kwargs[<span class="string">&quot;ignored_tables&quot;</span>]</span><br><span class="line">        self.__only_schemas = kwargs[<span class="string">&quot;only_schemas&quot;</span>]</span><br><span class="line">        self.__ignored_schemas = kwargs[<span class="string">&quot;ignored_schemas&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#Header</span></span><br><span class="line">        self.table_id = self._read_table_id()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Additional information</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.primary_key = table_map[self.table_id].data[<span class="string">&quot;primary_key&quot;</span>]</span><br><span class="line">            self.schema = self.table_map[self.table_id].schema</span><br><span class="line">            self.table = self.table_map[self.table_id].table</span><br><span class="line">        <span class="keyword">except</span> KeyError: <span class="comment">#If we have filter the corresponding TableMap Event</span></span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__only_tables <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.table <span class="keyword">not</span> <span class="keyword">in</span> self.__only_tables:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.__ignored_tables <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.table <span class="keyword">in</span> self.__ignored_tables:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.__only_schemas <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.schema <span class="keyword">not</span> <span class="keyword">in</span> self.__only_schemas:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.__ignored_schemas <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.schema <span class="keyword">in</span> self.__ignored_schemas:</span><br><span class="line">            self._processed = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#Event V2</span></span><br><span class="line">        <span class="keyword">if</span> self.event_type == BINLOG.WRITE_ROWS_EVENT_V2 <span class="keyword">or</span> \</span><br><span class="line">                self.event_type == BINLOG.DELETE_ROWS_EVENT_V2 <span class="keyword">or</span> \</span><br><span class="line">                self.event_type == BINLOG.UPDATE_ROWS_EVENT_V2:</span><br><span class="line">                self.flags, self.extra_data_length = struct.unpack(<span class="string">&#x27;&lt;HH&#x27;</span>, self.packet.read(<span class="number">4</span>))</span><br><span class="line">                <span class="keyword">if</span> self.extra_data_length &gt; <span class="number">2</span>:</span><br><span class="line">                    self.extra_data_type = struct.unpack(<span class="string">&#x27;&lt;B&#x27;</span>, self.packet.read(<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># ndb information</span></span><br><span class="line">                    <span class="keyword">if</span> self.extra_data_type == <span class="number">0</span>:</span><br><span class="line">                        self.nbd_info_length, self.nbd_info_format = struct.unpack(<span class="string">&#x27;&lt;BB&#x27;</span>, self.packet.read(<span class="number">1</span>))</span><br><span class="line">                        self.nbd_info = self.packet.read(self.nbd_info_length - <span class="number">2</span>)</span><br><span class="line">                    <span class="comment"># partition information</span></span><br><span class="line">                    <span class="keyword">elif</span> self.extra_data_type == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> self.event_type == BINLOG.UPDATE_ROWS_EVENT_V2:</span><br><span class="line">                            self.partition_id, self.source_partition_id = struct.unpack(<span class="string">&#x27;&lt;HH&#x27;</span>, self.packet.read(<span class="number">4</span>))</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.partition_id = struct.unpack(<span class="string">&#x27;&lt;H&#x27;</span>, self.packet.read(<span class="number">2</span>))[<span class="number">0</span>]</span><br><span class="line">                    <span class="comment"># etc</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.extra_data = self.packet.read(self.extra_info_length - <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.flags = struct.unpack(<span class="string">&#x27;&lt;H&#x27;</span>, self.packet.read(<span class="number">2</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#Body</span></span><br><span class="line">        self.number_of_columns = self.packet.read_length_coded_binary()</span><br><span class="line">        self.columns = self.table_map[self.table_id].columns</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.columns) == <span class="number">0</span>:  <span class="comment"># could not read the table metadata, probably already dropped</span></span><br><span class="line">            self.complete = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> self._fail_on_table_metadata_unavailable:</span><br><span class="line">                <span class="keyword">raise</span> TableMetadataUnavailableError(self.table)</span><br></pre></td></tr></table></figure>
<p>Across fitering the database/table, you can store the table ID into table map cache what you want when parsing TableMapEvent. For the CDC program, it only needs to parse the Header(to get table ID) of the RowEvents. Then, continue to handle the events if it is in the table map or just drop them if not.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2010.12597.pdf">https://arxiv.org/pdf/2010.12597.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/blackbeam/mysql_async">https://github.com/blackbeam/mysql_async</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/neverchanje/chgcap-rs">https://github.com/neverchanje/chgcap-rs</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2024/01/23/Ariel/" class="prev">PREV</a><a href="/2023/10/30/snowflake-stream/" class="next">NEXT</a></div><div class="copyright"><p>For Ariel, the most beautiful memories</p><p>Â© 2023 - 2024 <a href="https://Adooobe.github.io">Finch Xia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>