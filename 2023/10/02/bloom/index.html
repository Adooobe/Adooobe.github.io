<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Bloom Filter Implementation and Optimization · Finch's Blog</title><meta name="description" content="Bloom Filter Implementation and Optimization - Finchxia"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/Adooobe.github.io/favicon.png"><link rel="stylesheet" href="/Adooobe.github.io/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://Adooobe.github.io/Adooobe.github.io/atom.xml" title="Finch's Blog"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/Adooobe.github.io/atom.xml" title="Finch's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/Adooobe.github.io/" class="logo-link"><img src="/Adooobe.github.io/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/Adooobe.github.io/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/Adooobe.github.io/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Adooobe" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.xiaohongshu.com/user/profile/578ae95d82ec396a701d61d7?channelType=web_engagement_notification_page&amp;channelTabId=mentions" target="_blank" class="nav-list-link">RED</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Bloom Filter Implementation and Optimization</h1><div class="post-info">Oct 2, 2023</div><div class="post-content"><h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><h2 id="What-is-Bloom-Filter"><a href="#What-is-Bloom-Filter" class="headerlink" title="What is Bloom Filter"></a>What is Bloom Filter</h2><p>A bloom filter is a probabilistic data structure that is based on hashing. It is extremely space efficient and is typically used to add elements to a set and test if an element is in a set. Though, the elements themselves are not added to a set. Instead a hash of the elements is added to the set.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, m, k</span>):</span><br><span class="line">        self.m = m</span><br><span class="line">        self.k = k</span><br><span class="line">        self.data = [<span class="number">0</span>]*m</span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, element</span>):</span><br><span class="line">        <span class="keyword">if</span> self.k == <span class="number">1</span>:</span><br><span class="line">            hash1 = h1(element) % self.m</span><br><span class="line">            self.data[hash1] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.k == <span class="number">2</span>:</span><br><span class="line">            hash1 = h1(element) % self.m</span><br><span class="line">            hash2 = h2(element) % self.m</span><br><span class="line">            self.data[hash1] = <span class="number">1</span></span><br><span class="line">            self.data[hash2] = <span class="number">1</span></span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, element</span>):</span><br><span class="line">        <span class="keyword">if</span> self.k == <span class="number">1</span>:</span><br><span class="line">            hash1 = h1(element) % self.m</span><br><span class="line">            <span class="keyword">if</span> self.data[hash1] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Not in Bloom Filter&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> self.k == <span class="number">2</span>:</span><br><span class="line">            hash1 = h1(element) % self.m</span><br><span class="line">            hash2 = h2(element) % self.m</span><br><span class="line">            <span class="keyword">if</span> self.data[hash1] == <span class="number">0</span> <span class="keyword">or</span> self.data[hash2] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Not in Bloom Filter&quot;</span></span><br><span class="line">        prob = (<span class="number">1.0</span> - ((<span class="number">1.0</span> - <span class="number">1.0</span>/self.m) * (self.k*self.n))) * self.k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Might be in Bloom Filter with false positive probability &quot;</span>+<span class="built_in">str</span>(prob)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h1</span>(<span class="params">w</span>):</span><br><span class="line">    h = hashlib.md5(w)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>(h.digest().encode(<span class="string">&#x27;base64&#x27;</span>)[:<span class="number">6</span>])%<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h2</span>(<span class="params">w</span>):</span><br><span class="line">    h = hashlib.sha256(w)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>(h.digest().encode(<span class="string">&#x27;base64&#x27;</span>)[:<span class="number">6</span>])%<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>In this sample, we implement a simple Bloom Filter which has two hash function(controlled by <em>k</em>) to compute the position of input element in the bit array (named data, array size is <em>m</em>).</p>
<p>When an element inserts into BloomFilter, two positions will be changed to 1 in the bit array computed by hash function so that if the element comes again, BloomFilter will get and check if the two positions are both 1. So when other element comes, if any position is not 1, the element doesn’t exist in the data array.</p>
<p>It is worth noting that different elements can get same hash values computed by hash function. It means one grid in the bit array is not independently used by unique element but shared. In other words, it can be covered.</p>
<h2 id="drawback"><a href="#drawback" class="headerlink" title="drawback"></a>drawback</h2><p>As mentioned above, Bloom Filter can creat false positives that Bloom Filter has a certain probability of mistakenly identifying non-existent elements.</p>
<p>We have two choices of parameters when building a bloom filter, <code>m</code> and <code>k</code>. They should each be chosen to dampen the number of false positives as much as possible while still maintaining whatever space requirement the filter needs.</p>
<p>If we have a bloom filter with <code>m</code> bits and <code>k</code> hash functions, the probability that a certain bit will still be zero after one insertion is</p>
<p>$(1-1&#x2F;m)^k$</p>
<p>Then, after <code>n</code> insertions, the probability of it still being zero after <code>n</code> insertions is</p>
<p>$(1-1&#x2F;m)^{nk}$</p>
<p>So, that means the probability of a false positive is</p>
<p>$(1-(1-1&#x2F;m)^{nk})^k$</p>
<p>In each of these equations, raising the value of k (the number of hash functions) will make the probability of a false positive less likely. However, it is not computationally efficient to have an enormous value for <em>k</em>. To minimize this equation, we must choose the best <em>k</em>. We do it this way because we assume that the programmer has already chosen an <strong>m</strong> based on their space constraints and that they have some idea what their potential <em>n</em> will be. So the <em>k</em> value that minimizes that equation is</p>
<p>$k&#x3D;ln(2)⋅m&#x2F;n$</p>
<h2 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h2><h3 id="Hudi-Upsert"><a href="#Hudi-Upsert" class="headerlink" title="Hudi Upsert"></a>Hudi Upsert</h3><h3 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h3><p>See <a href="https://adooobe.github.io/2023/10/02/lsm-tree/">LSM-Tree</a></p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/294069121">White List Question</a></li>
<li><a target="_blank" rel="noopener" href="https://www.51cto.com/article/753025.html">Redis Cache Breakdown</a></li>
</ol>
<h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>There are two limitations that have always restricted the usage of Bloom Filter, bounded source and append-only. The following are several improvement methods that revolve around addressing these two issues.</p>
<h4 id="Scalable-Bloom-Filters-SBF"><a href="#Scalable-Bloom-Filters-SBF" class="headerlink" title="Scalable Bloom Filters (SBF)"></a>Scalable Bloom Filters (SBF)</h4><p><img src="/Adooobe.github.io/scalable_bloom_filter.png#pic_center" alt="scalable bloom filter structure"></p>
<p>when the filter reaches some fulfillness threshold, it becomes read-only and new bigger and writable filter is created in its place. If in its turn it becomes saturated, the operation is repeated. Every new filter, in order to keep the false positives rate close to the targeted one, has more hash functions than the previous filter.</p>
<p>In Scalable Bloom filter the membership test is applied on all created (read-only + writable) filters. If the item is missing in all filters, it’s considered as not existing. In the other side, if one of the filters reports its existence, it means that the element may be in the dataset. An important point to notice here is that Scalable Bloom filter uses a variant of Bloom filters where the bit vector is divided in <em>k</em> slices where each stores <em>M&#x2F;k</em> bits (<em>M</em> is the size of whole bit vector). Since the number of slices is equal to the number of hash functions, each hash function works on its own slice:</p>
<p><img src="/Adooobe.github.io/scalable_bloom_filter_slices.png#pic_center" alt="scalable bloom filter slices"></p>
<p>Thanks to the slices each element is always described by <em>k</em> bits resulting on more robust filter without the elements more prone to the false positives than the others.</p>
<h4 id="Counting-Bloom-Filter-CBF"><a href="#Counting-Bloom-Filter-CBF" class="headerlink" title="Counting Bloom Filter (CBF)"></a>Counting Bloom Filter (CBF)</h4><p>For the second question, CBF provides ability to delete elements in Bloom Filters. But unfortunately, the premise is that we must ensure that the deleted element is present in the Bloom filter.</p>
<p><img src="/Adooobe.github.io/counting_bloom_filter.png#pic_center" alt="counting bloom filter structure"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.waitingforcode.com/big-data-algorithms/scalable-bloom-filter/read">https://www.waitingforcode.com/big-data-algorithms/scalable-bloom-filter/read</a></li>
<li>Baquero, C., &amp; Almeida, J. (2007, January). Scalable bloom filters. In European Conference on Principles of Data Mining and Knowledge Discovery (pp. 244-256). Springer, Berlin, Heidelberg.</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/Adooobe.github.io/2023/10/02/lsm-tree/" class="prev">PREV</a></div><div class="copyright"><p>For yyh, foul-weather and lovely friend</p><p>© 2023 <a href="https://Adooobe.github.io/Adooobe.github.io">Finchxia</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>