<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Finch&#39;s Blog</title>
  
  
  <link href="https://adooobe.github.io/Adooobe.github.io/atom.xml" rel="self"/>
  
  <link href="https://adooobe.github.io/Adooobe.github.io/"/>
  <updated>2023-10-08T12:18:15.466Z</updated>
  <id>https://adooobe.github.io/Adooobe.github.io/</id>
  
  <author>
    <name>Finchxia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Apache Arrow For the first time</title>
    <link href="https://adooobe.github.io/Adooobe.github.io/2023/10/08/apache-arrow/"/>
    <id>https://adooobe.github.io/Adooobe.github.io/2023/10/08/apache-arrow/</id>
    <published>2023-10-08T12:17:14.000Z</published>
    <updated>2023-10-08T12:18:15.466Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>the principle and application of LSM Tree</title>
    <link href="https://adooobe.github.io/Adooobe.github.io/2023/10/02/lsm-tree/"/>
    <id>https://adooobe.github.io/Adooobe.github.io/2023/10/02/lsm-tree/</id>
    <published>2023-10-02T11:24:02.000Z</published>
    <updated>2023-10-12T05:36:36.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM Tree"></a>LSM Tree</h1><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul><li>Ordered</li><li>Block Storage(Disk)-oriented</li><li>Hierarchical</li></ul><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p><img src="/Adooobe.github.io/lsm_tree.png#pic_center" alt="LSM-Tree Structure"></p><h2 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h2><h3 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h3><p>When LSM Tree received a input(insert&#x2F;update&#x2F;delete) operation, to avoid accidental crashing or shutdown，It is neccessary to write ahead log(WAL) that saves operation records into log files.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Wal <span class="keyword">struct</span> &#123;</span><br><span class="line">f    *os.File</span><br><span class="line">path <span class="type">string</span></span><br><span class="line">lock sync.Locker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memtable"><a href="#Memtable" class="headerlink" title="Memtable"></a>Memtable</h3><p>Memtable is an append-only data structure (every node inserted cannot be changed by logical delete and removing duplicates based on update time.) like Binary search tree (e.g. RedBlack tree - LevelDB) or SkipList (e.g. HBase, more popular).</p><h3 id="Sorted-String-Table-SSTables"><a href="#Sorted-String-Table-SSTables" class="headerlink" title="Sorted String Table (SSTables)"></a>Sorted String Table (SSTables)</h3><p>Usually, a SSTable consists of an index block and multiple data blocks. Data block structure is as follows:</p><p><img src="/Adooobe.github.io/sstable.png#pic_center" alt="Sorted Strings Table"></p><p>where data is only ordered in segment layer rather than global.</p><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><h4 id="improve-read-performance"><a href="#improve-read-performance" class="headerlink" title="improve read performance"></a>improve read performance</h4><p>For LSM Tree, what we concerned is read performance rather than write. As data increases, some methods to improve read performance need to come into our pictures.</p><ul><li><strong>Sparse Index</strong></li></ul><p>As mentioned above, SStable has several segments that data are orderly stored. Without any optimization, we can also use binary search algorithm to find a certain element by scanning all the SStables and every Segments in each SStable unitl finding it. But unfortunately, for binary search algorithm, the minimum memory unit is segment for us to find the key in <em>O(logn)</em> or spent a Disk IO, both are too expensive in big data scenarios. So it is neccessary to  build a sparse index in memory to accelerate query efficiency.</p><p><img src="/Adooobe.github.io/sparse_index.png#pic_center" alt="sparse index"></p><blockquote><p>Sparse indexes only contain entries for documents that have the indexed field, even if the index field contains a null value. The index skips over any document that is missing the indexed field. The index is “sparse” because it does not include all documents of a collection.</p></blockquote><ul><li><strong>Bloom Filter</strong></li></ul><p>When the number of SStable increases in Disk, if some key is not present in the records, we need to scan all the SStable to find that key. Bloom filter is to overcome this issue. Unlike sparse indexes, <a href="https://adooobe.github.io/2023/10/02/bloom/">Bloom filters</a> are designed to address the performance issues that arise when querying for non-existent keys.</p><h3 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h3><h4 id="questions-in-query"><a href="#questions-in-query" class="headerlink" title="questions in query"></a>questions in query</h4><p>Let’s talk about query in LSM Tree first. There are two query methods: <em>point lookup query</em> and <em>range query</em>.</p><ul><li><strong>point lookup query</strong>: find the element what we want from new segment to old one.</li><li><strong>range query</strong>: when a big range query is executed, data have to be found in memtable, immutable memtable and multiple SSTalbes in different levels. (Notice: range query should be <strong>key range query</strong> like the follow picture)</li></ul><p><img src="/Adooobe.github.io/range_query.png#pic_center" alt="LSM Tree range query"></p><p>During range reads, the iterator will seek to the start range similar to point lookup (using Binary search with in SSTs) using<code>SeekTo()</code> call. After seeking to start range, there will be series of iterators created one for each memtable, one for each Level-0 files (because of overlapping nature of SSTs in L0) and one for each level later on. A merging iterator will collect keys from each of these iterators and gives the data in sorted order till the End range is reached.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">itr := txn.NewIterator(badger.DefaultIteratorOptions)   </span><br><span class="line"><span class="keyword">for</span> itr.Seek(<span class="string">&quot;startKey&quot;</span>); itr.Valid(); itr.Next() &#123;</span><br><span class="line">    item := itr.Item()</span><br><span class="line">    key := item.Key()</span><br><span class="line">    <span class="keyword">if</span> bytes.Compare(key, <span class="string">&quot;endKey&quot;</span>) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rest of the logic.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1. find <em>startkey</em> position (write as startPosition) by <code>seek()</code> and move sub iterator to <code>startPosition + 1</code></p><p>Step2. compare the sub iterators’ element, return the minimal value and move the itr pointer.</p><p>Step3. repeat Step2 until the returned element &gt; endkey</p><p>So in range query, as SSTables become more and more, query execution also becomes heavier and heavier.</p><h4 id="Sorted-Run"><a href="#Sorted-Run" class="headerlink" title="Sorted Run"></a>Sorted Run</h4><blockquote><p>LSM tree organizes files into several sorted runs. A sorted run consists of one or multiple <a href="https://nightlies.apache.org/flink/flink-table-store-docs-release-0.3/docs/concepts/file-layouts/#data-files">data file</a>s and each data file belongs to exactly one sorted run.</p><p><img src="/Adooobe.github.io/sorted_runs.png#pic_center" alt="sorted runs"></p><p>As you can see, different sorted runs may have overlapping primary key ranges, and may even contain the same primary key. When querying the LSM tree, all sorted runs must be combined and all records with the same primary key must be merged according to the user-specified <a href="https://nightlies.apache.org/flink/flink-table-store-docs-release-0.3/docs/features/table-types/#merge-engines">merge engine</a> and the timestamp of each record.</p></blockquote><p>In my opinion, in LSM Tree, a single logically ordered and no-repeat structure can be regarded as a <code>sorted run</code>.</p><h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><p><img src="/Adooobe.github.io/merge_policy.png#pic_center" alt="LSM Tree merge policies"></p><ul><li>tiered compaction(low write amplification)<br><img src="/Adooobe.github.io/size_tiered_compaction.png#pic_center" alt="size_tiered_compaction"><ul><li>high read and space amplification</li></ul></li><li>leveled compaction</li></ul><p>Like the picture above, leveled merge policies will merge SSTables into next level with the same range.</p><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><ul><li><strong>bLSM</strong></li><li><strong>Diff-Index LSM</strong></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.cnblogs.com/whuanle/p/16297025.html">https://www.cnblogs.com/whuanle/p/16297025.html</a></li><li><a href="https://www.geeksforgeeks.org/introduction-to-log-structured-merge-lsm-tree/">https://www.geeksforgeeks.org/introduction-to-log-structured-merge-lsm-tree/</a></li><li><a href="https://www.mongodb.com/docs/manual/core/index-sparse/#:~:text=Sparse%20indexes%20only%20contain%20entries,all%20documents%20of%20a%20collection">https://www.mongodb.com/docs/manual/core/index-sparse/#:~:text=Sparse%20indexes%20only%20contain%20entries,all%20documents%20of%20a%20collection</a>.</li><li><a href="https://hzhu212.github.io/posts/2d7c5edb/">https://hzhu212.github.io/posts/2d7c5edb/</a></li><li><a href="https://zhuanlan.zhihu.com/p/380013595">https://zhuanlan.zhihu.com/p/380013595</a></li><li><a href="https://github.com/facebook/rocksdb/wiki/Iterator-Implementation">https://github.com/facebook/rocksdb/wiki/Iterator-Implementation</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LSM-Tree&quot;&gt;&lt;a href=&quot;#LSM-Tree&quot; class=&quot;headerlink&quot; title=&quot;LSM Tree&quot;&gt;&lt;/a&gt;LSM Tree&lt;/h1&gt;&lt;h2 id=&quot;Feature&quot;&gt;&lt;a href=&quot;#Feature&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="LSM Storage" scheme="https://adooobe.github.io/Adooobe.github.io/tags/LSM-Storage/"/>
    
  </entry>
  
  <entry>
    <title>Bloom Filter Implementation and Optimization</title>
    <link href="https://adooobe.github.io/Adooobe.github.io/2023/10/02/bloom/"/>
    <id>https://adooobe.github.io/Adooobe.github.io/2023/10/02/bloom/</id>
    <published>2023-10-02T11:11:52.000Z</published>
    <updated>2023-10-03T08:44:27.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><h2 id="What-is-Bloom-Filter"><a href="#What-is-Bloom-Filter" class="headerlink" title="What is Bloom Filter"></a>What is Bloom Filter</h2><p>A bloom filter is a probabilistic data structure that is based on hashing. It is extremely space efficient and is typically used to add elements to a set and test if an element is in a set. Though, the elements themselves are not added to a set. Instead a hash of the elements is added to the set.</p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, m, k</span>):</span><br><span class="line">        self.m = m</span><br><span class="line">        self.k = k</span><br><span class="line">        self.data = [<span class="number">0</span>]*m</span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, element</span>):</span><br><span class="line">        <span class="keyword">if</span> self.k == <span class="number">1</span>:</span><br><span class="line">            hash1 = h1(element) % self.m</span><br><span class="line">            self.data[hash1] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.k == <span class="number">2</span>:</span><br><span class="line">            hash1 = h1(element) % self.m</span><br><span class="line">            hash2 = h2(element) % self.m</span><br><span class="line">            self.data[hash1] = <span class="number">1</span></span><br><span class="line">            self.data[hash2] = <span class="number">1</span></span><br><span class="line">        self.n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, element</span>):</span><br><span class="line">        <span class="keyword">if</span> self.k == <span class="number">1</span>:</span><br><span class="line">            hash1 = h1(element) % self.m</span><br><span class="line">            <span class="keyword">if</span> self.data[hash1] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Not in Bloom Filter&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> self.k == <span class="number">2</span>:</span><br><span class="line">            hash1 = h1(element) % self.m</span><br><span class="line">            hash2 = h2(element) % self.m</span><br><span class="line">            <span class="keyword">if</span> self.data[hash1] == <span class="number">0</span> <span class="keyword">or</span> self.data[hash2] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Not in Bloom Filter&quot;</span></span><br><span class="line">        prob = (<span class="number">1.0</span> - ((<span class="number">1.0</span> - <span class="number">1.0</span>/self.m) * (self.k*self.n))) * self.k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Might be in Bloom Filter with false positive probability &quot;</span>+<span class="built_in">str</span>(prob)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h1</span>(<span class="params">w</span>):</span><br><span class="line">    h = hashlib.md5(w)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>(h.digest().encode(<span class="string">&#x27;base64&#x27;</span>)[:<span class="number">6</span>])%<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h2</span>(<span class="params">w</span>):</span><br><span class="line">    h = hashlib.sha256(w)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>(h.digest().encode(<span class="string">&#x27;base64&#x27;</span>)[:<span class="number">6</span>])%<span class="number">10</span></span><br></pre></td></tr></table></figure><p>In this sample, we implement a simple Bloom Filter which has two hash function(controlled by <em>k</em>) to compute the position of input element in the bit array (named data, array size is <em>m</em>).</p><p>When an element inserts into BloomFilter, two positions will be changed to 1 in the bit array computed by hash function so that if the element comes again, BloomFilter will get and check if the two positions are both 1. So when other element comes, if any position is not 1, the element doesn’t exist in the data array.</p><p>It is worth noting that different elements can get same hash values computed by hash function. It means one grid in the bit array is not independently used by unique element but shared. In other words, it can be covered.</p><h2 id="drawback"><a href="#drawback" class="headerlink" title="drawback"></a>drawback</h2><p>As mentioned above, Bloom Filter can creat false positives that Bloom Filter has a certain probability of mistakenly identifying non-existent elements.</p><p>We have two choices of parameters when building a bloom filter, <code>m</code> and <code>k</code>. They should each be chosen to dampen the number of false positives as much as possible while still maintaining whatever space requirement the filter needs.</p><p>If we have a bloom filter with <code>m</code> bits and <code>k</code> hash functions, the probability that a certain bit will still be zero after one insertion is</p><p>$(1-1&#x2F;m)^k$</p><p>Then, after <code>n</code> insertions, the probability of it still being zero after <code>n</code> insertions is</p><p>$(1-1&#x2F;m)^{nk}$</p><p>So, that means the probability of a false positive is</p><p>$(1-(1-1&#x2F;m)^{nk})^k$</p><p>In each of these equations, raising the value of k (the number of hash functions) will make the probability of a false positive less likely. However, it is not computationally efficient to have an enormous value for <em>k</em>. To minimize this equation, we must choose the best <em>k</em>. We do it this way because we assume that the programmer has already chosen an <strong>m</strong> based on their space constraints and that they have some idea what their potential <em>n</em> will be. So the <em>k</em> value that minimizes that equation is</p><p>$k&#x3D;ln(2)⋅m&#x2F;n$</p><h2 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h2><h3 id="Hudi-Upsert"><a href="#Hudi-Upsert" class="headerlink" title="Hudi Upsert"></a>Hudi Upsert</h3><h3 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h3><p>See <a href="https://adooobe.github.io/2023/10/02/lsm-tree/">LSM-Tree</a></p><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/294069121">White List Question</a></li><li><a href="https://www.51cto.com/article/753025.html">Redis Cache Breakdown</a></li></ol><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>There are two limitations that have always restricted the usage of Bloom Filter, bounded source and append-only. The following are several improvement methods that revolve around addressing these two issues.</p><h4 id="Scalable-Bloom-Filters-SBF"><a href="#Scalable-Bloom-Filters-SBF" class="headerlink" title="Scalable Bloom Filters (SBF)"></a>Scalable Bloom Filters (SBF)</h4><p><img src="/Adooobe.github.io/scalable_bloom_filter.png#pic_center" alt="scalable bloom filter structure"></p><p>when the filter reaches some fulfillness threshold, it becomes read-only and new bigger and writable filter is created in its place. If in its turn it becomes saturated, the operation is repeated. Every new filter, in order to keep the false positives rate close to the targeted one, has more hash functions than the previous filter.</p><p>In Scalable Bloom filter the membership test is applied on all created (read-only + writable) filters. If the item is missing in all filters, it’s considered as not existing. In the other side, if one of the filters reports its existence, it means that the element may be in the dataset. An important point to notice here is that Scalable Bloom filter uses a variant of Bloom filters where the bit vector is divided in <em>k</em> slices where each stores <em>M&#x2F;k</em> bits (<em>M</em> is the size of whole bit vector). Since the number of slices is equal to the number of hash functions, each hash function works on its own slice:</p><p><img src="/Adooobe.github.io/scalable_bloom_filter_slices.png#pic_center" alt="scalable bloom filter slices"></p><p>Thanks to the slices each element is always described by <em>k</em> bits resulting on more robust filter without the elements more prone to the false positives than the others.</p><h4 id="Counting-Bloom-Filter-CBF"><a href="#Counting-Bloom-Filter-CBF" class="headerlink" title="Counting Bloom Filter (CBF)"></a>Counting Bloom Filter (CBF)</h4><p>For the second question, CBF provides ability to delete elements in Bloom Filters. But unfortunately, the premise is that we must ensure that the deleted element is present in the Bloom filter.</p><p><img src="/Adooobe.github.io/counting_bloom_filter.png#pic_center" alt="counting bloom filter structure"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://www.waitingforcode.com/big-data-algorithms/scalable-bloom-filter/read">https://www.waitingforcode.com/big-data-algorithms/scalable-bloom-filter/read</a></li><li>Baquero, C., &amp; Almeida, J. (2007, January). Scalable bloom filters. In European Conference on Principles of Data Mining and Knowledge Discovery (pp. 244-256). Springer, Berlin, Heidelberg.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bloom-Filter&quot;&gt;&lt;a href=&quot;#Bloom-Filter&quot; class=&quot;headerlink&quot; title=&quot;Bloom Filter&quot;&gt;&lt;/a&gt;Bloom Filter&lt;/h1&gt;&lt;h2 id=&quot;What-is-Bloom-Filter&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="Bloom-Filter" scheme="https://adooobe.github.io/Adooobe.github.io/tags/Bloom-Filter/"/>
    
  </entry>
  
</feed>
